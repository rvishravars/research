## Slide 1 — Title
Emphasize the paper’s central question: can we keep app context (reliability) without slowing phones? The novelty is **policy**, not new GC; it orchestrates LMK (kills) and kswapd (swap) together. :contentReference[oaicite:38]{index=38}

## Slide 2 — Motivation & Problem
Point out that LMK kills are invisible to users → nasty surprises (lost forms/edits). Early “no swap” was rational due to eMMC limits; but workloads + storage tech evolved. The study shows modern devices can tolerate **limited** swap well. :contentReference[oaicite:39]{index=39}

## Slide 3 — Background
Contrast **page-level** (kswapd) vs **process-level** (LMK). Stress that OOM rarely triggers in Android. Show **Figure 1** to anchor timing thresholds. :contentReference[oaicite:40]{index=40}

## Slide 4 — Swap vs Kill
Clarify the user-perceived difference: kill → cold start; swap → warm resume. But swap I/O can stall UI if uncontrolled. Use **Figure 2** to show legacy vs modern device I/O. :contentReference[oaicite:41]{index=41}

## Slide 5 — Architecture
Walk through classification → low-memory event → actions:
1) Swap pages of swap-targets (kswapd), 2) Kill kill-targets (LMK), 3) Enforce **cap** on swap targets; demote lowest-priority to kill-target to avoid thrash. Show **Figure 3**. :contentReference[oaicite:42]{index=42}

## Slide 6 — Classification & Priority
Criteria: does the app already persist meaningful state? Many do not. Priority affects which swap-target gets demoted when cap exceeded. Use **Table 1** examples. :contentReference[oaicite:43]{index=43}

## Slide 7 — Policy Variants
Define thresholds conceptually (kill-first raises kill-watermark, lowers swap watermark; swap-first opposite). Mention that Android minfree levels make this feasible. Use **Table 3**. :contentReference[oaicite:44]{index=44}

## Slide 8 — Setup & Workloads
Nexus 5 (2 GB) with swap file; automation via `am`. Scenarios A/B/C: count and ordering (seq vs random) and realistic locality (LiveLab). Compare **Original**, **Swap-all**, **Selective KF**, **Selective SF**. Use **Table 2** and **Figure 4**. :contentReference[oaicite:45]{index=45}

## Slide 9 — Results
Main messages:
- Light load: all fine; selective ≈ original.
- Heavy load: **Kill-first** wins (lower I/O, fewer stalls).
- Big win on **variance** (predictability).
Quote ranges **(+19–83% avg; –20–96% stdev)** vs swap-all. Show **Figures 5–9**. :contentReference[oaicite:46]{index=46}

## Slide 10 — I/O & Takeaways
I/O: swap-all worst; selective controlled; kill-first lowest writes in heavy cases. Flash endurance not a blocker if capped. Recommendations:
- Default to **kill-first** in heavy multitasking contexts.
- Allow **swap-first** when user experience of continuity matters and app count is small.
Future: adaptive policy, newer SoCs/Android, NVM swap. Use **Figure 11**. :contentReference[oaicite:47]{index=47}
