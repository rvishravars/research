# Maintaining App Context on Smartphones via 

**Selective Swap & Kill**
**IEEE Access, 2020 — Jisun Kim, Hyokyung Bahn**

- Problem: Android kills apps under low memory -> context loss
- Goal: Preserve app context **without** degrading performance
- Key idea: **Selective swap** for apps that need OS help; **kill** others
- Two policy variants: **Kill-first** and **Swap-first**
- Evaluated on real devices with realistic workloads

---

## Motivation & Problem
- Android LMK kills background apps when free RAM < threshold → **lost context**, cold restarts
- Traditional swap avoided on phones: heavy I/O, slow launches on older flash
- Observation: Modern devices show **far lower swap overhead** if managed judiciously
- Goal: Maintain reliability (app context) **and** responsiveness (launch latency)
- 👉 Use **software-only** scheme; no extra hardware
**Fig to include:** Paper abstract header; or a small problem diagram you create

---

## Background: Android Memory Reclamation
- **kswapd (Linux):** page-level reclamation (swap out cold pages)
- **LMK (Android):** process-level kills at higher free-memory thresholds
- **OOM:** emergency last resort if reclamation fails
- Implication: Android favors **kills** (fast, no I/O) but loses app state
**Use Figure 1** “Triggering conditions of LMK, kswapd, OOM” here
[oaicite:8]{index=8}

---

## Swap vs Kill — Rationale
- **Kill**
  - + Reclaims RAM quickly, no swap I/O
  - – **Context lost**, cold launch on return
- **Swap**
  - + Preserves full process context (heap/stack/code) for fast resume
  - – Adds read/write I/O; risk of thrashing at high app counts
- Key empirical finding: On modern phones, swap overhead is **manageable** until very high concurrency
**Use Figure 2** (I/O traffic comps: ODROID-Q vs Nexus 5) to show evolution


---

## Architecture: **Selective Swap Scheme**
- Classify apps:
  - **Swap-target**: do **not** self-save context → OS should swap
  - **Kill-target**: self-save context or no critical state → safe to kill
- On low memory:
  - Swap pages of **swap-target** apps (via kswapd)
  - Kill **kill-target** apps (via LMK)
- **Cap** the number of swapped apps to avoid thrashing; demote lowest-priority to kill-target if needed
**Use Figure 3** “Overview of the proposed scheme”


---

## Application Classification & Priority
- Heuristic: detect/assume **context-saving** behavior; Android state files as evidence
- Priority tiers (examples):
  - **High**: navigation, finance, office
  - **Medium**: social, multimedia, games
  - **Low**: info/ads/camera (foreground not killed)
- If swap set grows beyond limit → **demote** lowest-priority app from swap-target → kill-target
**Use Table 1** “Classification of applications and examples”


---

## Policy Variants & Thresholds
- **Kill-first**:
  - Higher **kill-threshold**; lower **swap-threshold**
  - Free RAM early by killing kill-targets; swap only if needed
  - Tends to reduce swap I/O; better under heavy load
- **Swap-first**:
  - Lower **kill-threshold**; higher **swap-threshold**
  - Prefer swapping swap-targets to retain context; kill last
- Implementation aligns with Android minfree watermarks
**Use Table 3** “Threshold parameter setting”


---

## Experimental Setup & Workloads
- Device: **Nexus 5** (2 GB LPDDR3, 2 GB swap file on eMMC), Android 6.0.1, Linux 3.4.0
- Launch automation via `am` + timed sleeps; repeated rounds[oaicite:24]{index=24}
- Scenarios:
  - **A1/A2 (~12 apps)**: light / typical user
  - **B1/B2 (~24 apps)**: heavy load
  - **C (~30 apps)**: realistic trace with locality (LiveLab mapping)
- Compared 4 schemes: **Original**, **Swap-all**, **Selective (Kill-first)**, **Selective (Swap-first)**
**Use Table 2** “Application scenarios” and **Figure 4** (launcher script)

---

## Results: Launch Time & Stability
- Light load (~12 apps): swap-all & selective ≈ original (no degradation)
- Heavy load (~24–30 apps):
  - **Selective Kill-first** best avg launch time; reduces swap I/O, avoids thrash
  - Selective schemes drastically **reduce variance** vs swap-all
- **Quantitative** (vs swap-all): **+19%–83%** faster average launches; **20%–96%** lower std dev
**Use Figures 5–9** (launch times per scenario)

---

## I/O Traffic & Practicality
- Swap-all: large write I/O; sometimes 8× vs original on old hw
- Modern device + **selective cap**:
  - I/O increase modest; acceptable under light/moderate loads
  - Kill-first further **cuts writes** under heavy concurrency
- Flash endurance: modern UFS/eMMC + controlled swap → not a blocker
**Use Figure 11** (read/write and swap vs non-swap I/O breakdown)

---

## Takeaways & Future Work
- **Selective Swap** preserves context **without** hurting performance on modern phones
- **Kill-first** recommended under heavy loads; **Swap-first** for light loads prioritizing context
- Contributions:
  - First practical OS policy combining LMK & kswapd by **context-awareness**
  - Evidence that swap is viable again on smartphones (with limits)
- Next steps:
  - Adaptive policies; dynamic classification
  - Newer Android/SoCs; explore NVM/NVMe swap
**Images to include:** Figs 1–3, 5–9, 11; Tables 1–3
