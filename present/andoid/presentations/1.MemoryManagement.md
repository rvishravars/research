# INFO411 Memory Management on Mobile Devices
## ISMM 2024 ‚Äì Memory Management on Mobile Devices

---

## Motivation

- üì± Billions of mobile devices, yet memory management is understudied compared to servers/desktops.
- **Responsiveness (frame rate), energy (cpu/battery), and memory cost (heap size)** are critical to user experience.
- Android Runtime (ART), part of the **Android OS**, is:
  - Open-source
  - Garbage-collected
  - Runs across low- to high-end devices
- ‚ùìHow do OS garbage collectors behave on *real-world mobile apps*‚ùì

<div style="text-align: center; margin-top: 0.5rem;">
<a href="#background" style="font-size: 2rem; text-decoration: none;">‚¨áÔ∏è Next</a>
</div>

---

## Background ‚Äì ART Runtime

- **Android Runtime (ART):**
  - Zygote ‚Üí forks every app process
  - Both **JIT** and **AOT** compilation available
  - Collectors: SemiSpace, Concurrent Copying, Concurrent Mark-Compact
- **OS level GC ‚â† app-level GC**
  - Impacts *all apps* sharing the OS
  - Must measure **mutator cost** + **responsiveness**

---

## Architecture

![Architecture](images/android-stack_2x.png)

---

## Challenges

- **Multi-tenancy**: Many apps/services share limited OS memory.
- **Lack of benchmarks**: No standard suite of open-source Android OS apps.
- **Non-determinism**: Network, GPS, UI events ‚Üí reproducibility issues.
- **Heap size control**: Apps inherit from the OS Zygote ‚Üí hard to tune per-app.
- **Heap introspection loops**: Apps adapt to OS memory pressure.
- **Closed-source apps**: Frequent updates + UI changes ‚Üí flaky benchmarks.

‚ùìHow can OS-level GC overheads be measured in a *controlled & reproducible* way‚ùì

---

## Framework Design ‚Äì Key Principles

- **Heap size control**  
  - Hijacked **Zygote fork** to enforce per-app heap limits  
  - First systematic mechanism for OS-level GC evaluation  

- **GC cost attribution**  
  - Extended ART to log **GC phases**  
  - Collected **perf counters**:  
    - CPU cycles, Task clock 
    - **Instructions retired**
    - Page faults
  - Also measured wall-clock time, but discarded because *too noisy*  

---

## Framework Design ‚Äì Key Principles

- **Responsiveness metrics**  
  - Measured **frame jank & render times** via `gfxinfo`  
  - User-visible latency, not just GC pause times  
  - **Percentiles (P50, P99, P99.9)** for frame times to capture stutter  

---

## Framework Design ‚Äì Pipeline

**App ‚Üí Modified ART ‚Üí Mock APIs ‚Üí UI Automator ‚Üí Metrics**
- Controlled heap (size) configuration at fork
- Mocked heap introspection APIs ‚Üí stable values
- Automated user events via **UI Automator**
- Logged GC timings + frame stability (Brief pause stutter)

---

## Framework Design ‚Äì Challenges Addressed

- **Heap introspection feedback loops**  
  - Maps, Instagram adapt to ‚Äúavailable memory‚Äù  
  - Solution: Fake responses via modified ART  

- **Non-determinism**  
  - Cached TikTok feeds & fixed content  
  - Forced **AOT compilation** ‚Üí steady state  

- **Idempotent benchmarks**  
  - Cold-start every run  
  - Fixed app versions, reproducible UI scripts  

---

## Garbage Collection

![Architecture](images/GC.png)

---

## Cleaners (Collectors)

- **Generational Concurrent Copying Cleaner** üßí
  - ‚ÄúQuick tidy-up kid‚Äù
  - Frequent, lightweight cleanups
  - Write barrier + read barrier ensure safety (references + movement + integrity)

---

## Cleaners (Collectors)

- **Concurrent Mark-Compact Cleaner** üßì
  - ‚ÄúDeep-cleaning parent‚Äù
  - Less frequent, re-organizes heap
  - More space-efficient for long-lived workloads

---

## Benchmarks ‚Äì Design

- **Vanilla Java benchmarks**  
  - DaCapo subset, GCBench  
  - Controlled, stable workloads  

- **Real-world apps**  
  - Gmail, TikTok, Instagram, Maps, Acrobat, Airbnb  
  - Represent actual OS-level stressors  

- Excluded: browsers & games (too dynamic, non-reproducible)

---

## Evaluation Framework

- Modified **ART** to:
  - Control heap per-app (Zygote fork)
  - Mock heap APIs (break feedback loops)
  - Automate UI input sequences
- ‚ùìCan OS-level collectors be measured fairly for both **mutator cost** and **responsiveness**‚ùì

---

## Evaluation ‚Äì Methodology

- **Devices:** Pixel 7 Pro (12 GB), Pixel 4a 5G (6 GB)  
- **Controls:**  
  - Disabled SIM/Bluetooth/location  
  - Fixed CPU frequency, pinned cores  
  - Forced AOT warmup  
- **Lower Bound Overhead (LBO):**  
  - SemiSpace/NoGC as baselines  
  - Reported results = empirical *lower bounds* on GC cost  
- ‚öñÔ∏è **CPU cycles reported slightly higher overhead than task clock** ‚Üí apps did extra work, not just slowing  

---

## Evaluation ‚Äì Vanilla Java Workloads

- **Optimized SemiSpace:** lowest mutator overheads (14‚Äì27%) / CPU Cycle / Task Clock ...  
- **Concurrent Copying (CC):** 10‚Äì23%, cache-friendly(less cache miss) at small heaps  
- **Concurrent Mark-Compact (CMC):** 11‚Äì32%, more space-efficient
- **Takeaway:** No single collector dominates  

---

## Evaluation ‚Äì Real-World Apps

- Overheads: **2% ‚Äì 51%**, strongly app + heap dependent  
- **Trends:**  
  - SemiSpace (optimized) ‚Üí best for mutator overhead  
  - CMC ‚Üí better for tight heaps (e.g., Maps)  
  - Pause times (short/frequent) ‚â† responsiveness 

---

## Evaluation ‚Äì Responsiveness

- Frame distributions (Gmail, Acrobat)  
  - P50, P99, P99.9 ‚Üí smoothness vs jank  
  - 99.9th percentile ‚Üí **stutter** despite short pause times  
- Insight: Must use **frame stability metrics**, not just stop-the-world pauses  
- Different apps show unique GC sensitivity patterns  

---

## Evaluation ‚Äì Anomalies

- **Twitter/X:** highly unstable ‚Üí discarded from results  
- **Google Maps:** minimum heap size changed **daily** with updates  
- ‚ùó Highlights difficulty of reproducibility with closed-source apps  

---

## Evaluation ‚Äì Experimental Device

**Pixel 7 Pro**

| Component | Specification |
|-----------|---------------|
| CPU       | 2√ó Cortex-X1 @2.85GHz <br> 2√ó Cortex-A78 @2.35GHz <br> 4√ó Cortex-A55 @1.8GHz |
| Memory    | 12 GB LPDDR5 |

---

## Evaluation ‚Äì Heap Sizes (Apps)

**Minimum Heap Sizes (MB)**

| Benchmark     | Pixel 7 Pro | Pixel 4a 5G |
|---------------|-------------|-------------|
| Acrobat       | 18          | 18 |
| Airbnb        | 23          | 23 |
| Discord       | 19          | 19 |
| Gmail         | 14          | 14 |
| Google News   | 14          | 17 |
| Maps          | 65          | 65 |

---

## Evaluation ‚Äì Key Results

- GC overheads: **2% ‚Üí 51%**  
- **SemiSpace (optimized):** best mutator overhead  
- **CMC:** most space-efficient  
- **Responsiveness metrics:**  
  - Pause times ‚â† user experience  
  - **Frame stability (percentiles)** = better predictor

---

![Results Chart](images/1-1-result.png)

---

![Results Chart](images/2-result.png)

---

## Discussion ‚Äì Time vs Space Tradeoff

- **SemiSpace:** low mutator cost, but higher heap demand  
- **CMC:** space-efficient, but overhead increases with workload  
- **Concurrent Copying:** good balance for smaller heaps  
- ‚ùå No universal best GC across workloads  

---

## Discussion ‚Äì What Surprised

- SemiSpace often outperformed concurrent collectors  
- Pause time metrics failed as predictors of responsiveness  
- Closed-source app volatility (heap growth, updates) complicates research  

---

## Summary Takeaways

- **Framework:** First systematic GC evaluation for Android  
- **Evaluation:** Benchmarks across real apps + Java workloads  
- **Tradeoffs:** SemiSpace -> lowest overhead; CMC -> most space-efficient  
- **Responsiveness:** Frame stability (P50/P99/P99.9) > pause times  

---

## Future Improvements

- Build **open-source benchmark suite** for reproducibility  
- Stronger solutions to **heap introspection loops**  
- Improve reproducibility under **dynamic events**  
- Extend framework to **other mobile OSes**  
- Explore collectors optimizing **time-space tradeoffs** for small heaps  

‚ùìWhat OS GC designs can sustain performance across *all tiers of devices*‚ùì

![Future Work](images/future_directions.png)
